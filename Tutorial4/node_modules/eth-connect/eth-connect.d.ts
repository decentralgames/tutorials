import { IFuture } from 'fp-future';

declare abstract class AbstractFilter<T> {
    requestManager: RequestManager;
    isStarted: boolean;
    isDisposed: boolean;
    formatter: (x: any) => T;
    protected filterId: IFuture<Data>;
    protected callbacks: ((message: T) => void)[];
    protected stopSemaphore: IFuture<any>;
    constructor(requestManager: RequestManager);
    watch(callback: (message: T) => void): Promise<void>;
    start(): Promise<void>;
    stop(): Promise<void>;
    protected abstract getNewFilter(): Promise<Data>;
    protected abstract getChanges(): Promise<any>;
    protected abstract uninstall(): Promise<any>;
    /**
     * Adds the callback and sets up the methods, to iterate over the results.
     */
    private poll;
}

/** Hex string of 20 bytes */
declare type Address = string;

declare interface BigNumber {
    /**
     * Returns the value of this BigNumber as a JavaScript primitive number.
     *
     * Using the unary plus operator gives the same result.
     *
     * ```ts
     * x = new BigNumber(456.789)
     * x.toNumber()                    // 456.789
     * +x                              // 456.789
     * y = new BigNumber('45987349857634085409857349856430985')
     *
     * y.toNumber()                    // 4.598734985763409e+34
     *
     * z = new BigNumber(-0)
     * 1 / z.toNumber()                // -Infinity
     * 1 / +z                          // -Infinity
     * ```
     */
    toNumber(): number;
    /**
     * Returns a string representing the value of this BigNumber in base `base`, or base 10 if `base`
     * is omitted or is `null` or `undefined`.
     *
     * For bases above 10, and using the default base conversion alphabet (see `ALPHABET`), values
     * from 10 to 35 are represented by a-z (the same as `Number.prototype.toString`).
     *
     * If a base is specified the value is rounded according to the current `DECIMAL_PLACES` and
     * `ROUNDING_MODE` settings, otherwise it is not.
     *
     * If a base is not specified, and this BigNumber has a positive exponent that is equal to or
     * greater than the positive component of the current `EXPONENTIAL_AT` setting, or a negative
     * exponent equal to or less than the negative component of the setting, then exponential notation
     * is returned.
     *
     * If `base` is `null` or `undefined` it is ignored.
     *
     * Throws if `base` is invalid.
     *
     * ```ts
     * x = new BigNumber(750000)
     * x.toString()                    // '750000'
     * config({ EXPONENTIAL_AT: 5 })
     * x.toString()                    // '7.5e+5'
     *
     * y = new BigNumber(362.875)
     * y.toString(2)                   // '101101010.111'
     * y.toString(9)                   // '442.77777777777777777778'
     * y.toString(32)                  // 'ba.s'
     *
     * config({ DECIMAL_PLACES: 4 });
     * z = new BigNumber('1.23456789')
     * z.toString()                    // '1.23456789'
     * z.toString(10)                  // '1.2346'
     * ```
     *
     * @param [base] The base, integer, 2 to 36 (or `ALPHABET.length`, see `ALPHABET`).
     */
    toString(base?: number): string;
    /**
     * As `toString`, but does not accept a base argument and includes the minus sign for negative
     * zero.
     *
     * ``ts
     * x = new BigNumber('-0')
     * x.toString()                    // '0'
     * x.valueOf()                     // '-0'
     * y = new BigNumber('1.777e+457')
     * y.valueOf()                     // '1.777e+457'
     * ```
     */
    valueOf(): string;
    /**
     * Returns a BigNumber whose value is the value of this BigNumber divided by `n`, rounded
     * according to the current `DECIMAL_PLACES` and `ROUNDING_MODE` settings.
     *
     * ```ts
     * x = new BigNumber(355)
     * y = new BigNumber(113)
     * x.dividedBy(y)                  // '3.14159292035398230088'
     * x.dividedBy(5)                  // '71'
     * x.dividedBy(47, 16)             // '5'
     * ```
     *
     * @param n A numeric value.
     * @param [base] The base of n.
     */
    dividedBy(n: BigNumberValueType, base?: number): BigNumber;
    /**
     * Returns a BigNumber whose value is the value of this BigNumber rounded to an integer using
     * rounding mode `rm`.
     *
     * If `rm` is omitted, or is `null` or `undefined`, `ROUNDING_MODE` is used.
     *
     * Throws if `rm` is invalid.
     *
     * ```ts
     * x = new BigNumber(123.456)
     * x.integerValue()                        // '123'
     * x.integerValue(BigNumber.ROUND_CEIL)    // '124'
     * y = new BigNumber(-12.7)
     * y.integerValue()                        // '-13'
     * x.integerValue(BigNumber.ROUND_DOWN)    // '-12'
     * ```
     *
     * @param {BigNumber.RoundingMode} [rm] The roundng mode, an integer, 0 to 8.
     */
    integerValue(rm?: BigNumberRoundingModeType): BigNumber;
    /**
     * Returns `true` if the value of this BigNumber is less than the value of `n`, otherwise returns
     * `false`.
     *
     * ```ts
     * (0.3 - 0.2) < 0.1                       // true
     * x = new BigNumber(0.3).minus(0.2)
     * x.isLessThan(0.1)                       // false
     * BigNumber(0).isLessThan(x)              // true
     * BigNumber(11.1, 2).isLessThan(11, 3)    // true
     * ```
     *
     * @param n A numeric value.
     * @param [base] The base of n.
     */
    isLessThan(n: BigNumberValueType, base?: number): boolean;
    /**
     * Returns a BigNumber whose value is the value of this BigNumber multiplied by `n`.
     *
     * The return value is always exact and unrounded.
     *
     * ```ts
     * 0.6 * 3                         // 1.7999999999999998
     * x = new BigNumber(0.6)
     * y = x.times(3)                  // '1.8'
     * BigNumber('7e+500').times(y)    // '1.26e+501'
     * x.times('-a', 16)               // '-6'
     * ```
     *
     * @param n A numeric value.
     * @param [base] The base of n.
     */
    times(n: BigNumberValueType, base?: number): BigNumber;
}

declare type BigNumberRoundingModeType = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;

declare type BigNumberValueType = string | number | BigNumber;

declare type BlockIdentifier = Quantity | Tag;

declare type BlockObject = {
    /** the block number. null when its pending block. */
    number: Quantity;
    /** hash of the block. null when its pending block. */
    hash: TxHash;
    /** hash of the parent block. */
    parentHash: TxHash;
    /** hash of the generated proof-of-work. null when its pending block. 8 Bytes  */
    nonce: Data;
    /** SHA3 of the uncles data in the block. */
    sha3Uncles: TxHash;
    /** the bloom filter for the logs of the block. null when its pending block. 256 Bytes */
    logsBloom: Data;
    /** the root of the transaction trie of the block. */
    transactionsRoot: TxHash;
    /** the root of the final state trie of the block. */
    stateRoot: TxHash;
    /** the root of the receipts trie of the block. */
    receiptsRoot: TxHash;
    /** the address of the beneficiary to whom the mining rewards were given. */
    miner: Address;
    /** integer of the difficulty for this block. */
    difficulty: Quantity;
    /** integer of the total difficulty of the chain until this block. */
    totalDifficulty: Quantity;
    /** the "extra data" field of this block. */
    extraData: Data;
    /** integer the size of this block in bytes. */
    size: Quantity;
    /** the maximum gas allowed in this block. */
    gasLimit: Quantity;
    /** the total used gas by all transactions in this block. */
    gasUsed: Quantity;
    /** the unix timestamp for when the block was collated. */
    timestamp: Quantity;
    /** Array of transaction objects, or 32 Bytes transaction hashes depending on the last given parameter. */
    transactions: Array<TxHash> | Array<TransactionObject>;
    /** Array of uncle hashes */
    uncles: Array<TxHash>;
};

declare type Callback = (err: Error | null, message?: any) => void;

declare type ConfirmedTransaction = TransactionObject & {
    type: TransactionType.confirmed;
    receipt: TransactionReceipt;
};

/**
 * @public
 * Should be called to create new contract instance
 */
export declare class Contract {
    requestManager: RequestManager;
    abi: any[];
    address: string;
    allEvents: (options: FilterOptions) => Promise<EthFilter>;
    events: {
        [key: string]: EventFilterCreator;
    };
    transactionHash: string;
    constructor(requestManager: RequestManager, abi: any[], address: string);
}

/**
 * @public
 * Should be called to create new ContractFactory instance
 */
export declare class ContractFactory {
    requestManager: RequestManager;
    abi: any[];
    constructor(requestManager: RequestManager, abi: any[]);
    /**
     * Should be called to create new contract on a blockchain
     */
    deploy(param1: any, param2: any, options: TransactionOptions): Promise<Contract>;
    deploy(param1: any, options: TransactionOptions): Promise<Contract>;
    deploy(options: TransactionOptions): Promise<Contract>;
    /**
     * Should be called to get access to existing contract on a blockchain
     *
     * @param address - The contract address
     */
    at(address: string): Promise<Contract>;
    /**
     * Gets the data, which is data to deploy plus constructor params
     */
    getData(...args: any[]): Promise<Data>;
}

/** Hex string */
declare type Data = string;

declare type DroppedTransaction = {
    type: TransactionType.dropped;
    hash: string;
    nonce: number;
};

declare class EthFilter<T = FilterChange | string> extends AbstractFilter<T> {
    requestManager: RequestManager;
    options: FilterOptions;
    formatter: (message: FilterChange | string) => T;
    constructor(requestManager: RequestManager, options: FilterOptions, formatter?: (message: FilterChange | string) => T);
    getLogs(): Promise<string[] | FilterChange[]>;
    protected getNewFilter(): Promise<any>;
    protected getChanges(): Promise<any>;
    protected uninstall(): Promise<any>;
}

declare type EventFilterCreator = (indexed: {
    [key: string]: any;
}, options?: FilterOptions) => Promise<EthFilter>;

declare type FilterChange = {
    /** true when the log was removed, due to a chain reorganization. false if its a valid log. */
    removed: boolean;
    /** integer of the log index position in the block. null when its pending log. */
    logIndex: Quantity;
    /** integer of the transactions index position log was created from. null when its pending log. */
    transactionIndex: Quantity;
    /** hash of the transactions this log was created from. null when its pending log. */
    transactionHash: TxHash;
    /** hash of the block where this log was in. null when its pending. null when its pending log. */
    blockHash: TxHash;
    /** the block number where this log was in. null when its pending. null when its pending log. */
    blockNumber: Quantity;
    /** address from which this log originated. */
    address: Address;
    /** contains one or more 32 Bytes non-indexed arguments of the log. */
    data: Data;
    /**
     * Array of 0 to 4 32 Bytes DATA of indexed log arguments. (In solidity: The first topic is the hash of the signature
     * of the event (e.g. Deposit(address,bytes32,uint256)), except you declared the event with the anonymous specifier.)
     */
    topics: Array<Data>;
};

declare type FilterLog = {};

declare type FilterOptions = {
    /** (optional, default: "latest") Integer block number, or "latest" for the last mined block or "pending", "earliest" for not yet mined transactions. */
    fromBlock?: BlockIdentifier;
    /** (optional, default: "latest") Integer block number, or "latest" for the last mined block or "pending", "earliest" for not yet mined transactions. */
    toBlock?: BlockIdentifier;
    /** (optional) Contract address or a list of addresses from which logs should originate. */
    address?: Data | Address;
    /** (optional) Array of 32 Bytes DATA topics. Topics are order-dependent. Each topic can also be an array of DATA with "or" options. */
    topics?: Array<Data>;
};

declare type FinishedTransactionAndReceipt = TransactionAndReceipt & {
    status: TransactionStatus;
};

/**
 * @public
 *
 * HttpProvider should be used to send rpc calls over http
 */
export declare class HTTPProvider {
    host: string;
    options: HTTPProviderOptions;
    debug: boolean;
    constructor(host: string, options?: HTTPProviderOptions);
    send(): void;
    /**
     * Should be used to make async request
     */
    sendAsync(payload: RPCMessage | RPCMessage[], callback: Callback): void;
}

declare type HTTPProviderOptions = {
    headers?: {
        [key: string]: string;
    };
    timeout?: number;
};

declare type Hex = string;

declare interface IPropertyOptions<V> {
    getter: string;
    outputFormatter: (_: any) => V;
}

declare interface IWebSocket {
    close(): any;
    send(s: any): any;
}

/**
 * @public
 */
export declare class Method<V> {
    callName: string;
    params: number;
    inputFormatter: Function[] | null;
    outputFormatter: (something: any) => V;
    requestManager: RequestManager;
    constructor(options: {
        callName: string;
        params: number;
        inputFormatter?: any[];
        outputFormatter: (val: any) => V;
    });
    /**
     * Should be called to check if the number of arguments is correct
     *
     * @param arguments - The list of arguments
     */
    validateArgs(args: any[]): void;
    /**
     * Should be called to format input args of method
     *
     * @param args - The array of arguments
     */
    formatInput(args: any[]): any[];
    /**
     * Should be called to format output(result) of method
     *
     * @param result - The result to be formatted
     */
    formatOutput(result: any): V | null;
    /**
     * Should create payload from given input args
     *
     * @param args - The given input arguments
     */
    toPayload(args: any[]): {
        method: string;
        params: any[];
    };
    execute(requestManager: RequestManager, ...args: any[]): Promise<V>;
}

declare type PendingTransaction = TransactionObject & {
    type: TransactionType.pending;
};

/**
 * @public
 */
export declare class Property<V> {
    getter: string;
    outputFormatter: Function | null;
    constructor(options: IPropertyOptions<V>);
    /**
     * Should be called to format output(result) of method
     *
     * @param result - The result to be formatted
     */
    formatOutput(result: any): any;
    execute(requestManager: RequestManager): Promise<any>;
}

declare type Quantity = number | Hex;

declare type QueuedTransaction = {
    type: TransactionType.queued;
    hash: string;
    nonce: number;
};

declare type RPCMessage = {
    jsonrpc: '2.0';
    id: number;
    method: string;
    params: any[] | {
        [key: string]: any;
    };
};

declare type RPCSendableMessage = {
    method: string;
    params: any[];
};

declare type ReplacedTransaction = {
    type: TransactionType.replaced;
    hash: string;
    nonce: number;
};

/**
 * @public
 * It's responsible for passing messages to providers
 * It's also responsible for polling the ethereum node for incoming messages
 * Default poll timeout is 1 second
 */
export declare class RequestManager {
    provider: any;
    /** Returns the current client version. */
    web3_clientVersion: () => Promise<string>;
    /** Returns Keccak-256 (not the standardized SHA3-256) of the given data. */
    web3_sha3: (data: Data) => Promise<Data>;
    /** Returns the current network id. */
    net_version: () => Promise<string>;
    /** Returns number of peers currently connected to the client. */
    net_peerCount: () => Promise<Quantity>;
    /** Returns true if client is actively listening for network connections. */
    net_listening: () => Promise<boolean>;
    /** Returns the current ethereum protocol version. */
    eth_protocolVersion: () => Promise<number>;
    /** Returns an object with data about the sync status or false. */
    eth_syncing: () => Promise<false | Syncing>;
    /** Returns the client coinbase address. */
    eth_coinbase: () => Promise<Address>;
    /** Returns true if client is actively mining new blocks. */
    eth_mining: () => Promise<boolean>;
    /** Returns the number of hashes per second that the node is mining with. */
    eth_hashrate: () => Promise<Quantity>;
    /** Returns the current price per gas in wei. */
    eth_gasPrice: () => Promise<BigNumber>;
    /** Returns a list of addresses owned by client. */
    eth_accounts: () => Promise<Address[]>;
    /** Returns the number of most recent block. */
    eth_blockNumber: () => Promise<Quantity>;
    /** Returns the balance of the account of given address. */
    eth_getBalance: (address: Address, block: BlockIdentifier) => Promise<BigNumber>;
    /** Returns the value from a storage position at a given address. */
    eth_getStorageAt: (address: Address, position: Quantity, block: BlockIdentifier) => Promise<Data>;
    /** Returns the number of transactions sent from an address. */
    eth_getTransactionCount: (address: Address, block: BlockIdentifier) => Promise<number>;
    /** Returns the number of transactions in a block from a block matching the given block hash. */
    eth_getBlockTransactionCountByHash: (blockHash: TxHash) => Promise<number>;
    /** Returns the number of transactions in a block matching the given block number. */
    eth_getBlockTransactionCountByNumber: (block: BlockIdentifier) => Promise<number>;
    /** Returns the number of uncles in a block from a block matching the given block hash. */
    eth_getUncleCountByBlockHash: (blockHash: TxHash) => Promise<number>;
    /** Returns the number of uncles in a block from a block matching the given block number. */
    eth_getUncleCountByBlockNumber: (block: BlockIdentifier) => Promise<number>;
    /** Returns code at a given address. */
    eth_getCode: (address: Address, block: BlockIdentifier) => Promise<Data>;
    /**
     * The sign method calculates an Ethereum specific signature with:
     *
     * sign(keccak256("Ethereum Signed Message:" + len(message) + message))).
     *
     * By adding a prefix to the message makes the calculated signature recognisable as an Ethereum specific signature.
     * This prevents misuse where a malicious DApp can sign arbitrary data (e.g. transaction) and use the signature to
     * impersonate the victim.
     *
     * Note the address to sign with must be unlocked.
     *
     * @deprecated see https://github.com/ethereum/go-ethereum/pull/2940
     */
    eth_sign: (address: Address, message: Data) => Promise<Data>;
    /** Creates new message call transaction or a contract creation, if the data field contains code. */
    eth_sendTransaction: (options: TransactionOptions) => Promise<TxHash>;
    /** Creates new message call transaction or a contract creation for signed transactions. */
    eth_sendRawTransaction: (rawTransaction: Data) => Promise<TxHash>;
    /** Executes a new message call immediately without creating a transaction on the block chain. */
    eth_call: (options: TransactionCallOptions, block: BlockIdentifier) => Promise<Data>;
    /**
     * Generates and returns an estimate of how much gas is necessary to allow the transaction to complete.
     * The transaction will not be added to the blockchain. Note that the estimate may be significantly more
     * than the amount of gas actually used by the transaction, for a variety of reasons including EVM mechanics
     * and node performance.
     */
    eth_estimateGas: (data: Partial<TransactionCallOptions> & Partial<TransactionOptions>) => Promise<Quantity>;
    /** Returns information about a block by hash. */
    eth_getBlockByHash: (blockHash: TxHash, fullTransactionObjects: boolean) => Promise<BlockObject>;
    /** Returns information about a block by block number. */
    eth_getBlockByNumber: (block: BlockIdentifier, fullTransactionObjects: boolean) => Promise<BlockObject>;
    /** Returns the information about a transaction requested by transaction hash. */
    eth_getTransactionByHash: (hash: TxHash) => Promise<TransactionObject>;
    /** Returns information about a transaction by block hash and transaction index position. */
    eth_getTransactionByBlockHashAndIndex: (blockHash: TxHash, txIndex: Quantity) => Promise<TransactionObject>;
    /** Returns information about a transaction by block number and transaction index position. */
    eth_getTransactionByBlockNumberAndIndex: (block: BlockIdentifier, txIndex: Quantity) => Promise<TransactionObject>;
    /**
     * Returns the receipt of a transaction by transaction hash.
     * Note That the receipt is not available for pending transactions.
     */
    eth_getTransactionReceipt: (hash: TxHash) => Promise<TransactionReceipt>;
    /** Returns information about a uncle of a block by hash and uncle index position. */
    eth_getUncleByBlockHashAndIndex: (blockHash: TxHash, index: Quantity) => Promise<BlockObject>;
    /** Returns information about a uncle of a block by number and uncle index position. */
    eth_getUncleByBlockNumberAndIndex: (block: BlockIdentifier, index: Quantity) => Promise<BlockObject>;
    /**
     * Creates a filter object, based on filter options, to notify when the state changes (logs). To check if the state
     * has changed, call eth_getFilterChanges.
     *
     * A note on specifying topic filters:
     * Topics are order-dependent. A transaction with a log with topics [A, B] will be matched by the following topic
     * filters:
     *
     * [] "anything"
     * [A] "A in first position (and anything after)"
     * [null, B] "anything in first position AND B in second position (and anything after)"
     * [A, B] "A in first position AND B in second position (and anything after)"
     * [[A, B], [A, B]] "(A OR B) in first position AND (A OR B) in second position (and anything after)"
     */
    eth_newFilter: (options: FilterOptions) => Promise<Data>;
    /**
     * Creates a filter in the node, to notify when a new block arrives. To check if the state has changed, call
     * eth_getFilterChanges.
     */
    eth_newBlockFilter: () => Promise<Data>;
    /**
     * Creates a filter in the node, to notify when new pending transactions arrive. To check if the state has changed,
     * call eth_getFilterChanges.
     */
    eth_newPendingTransactionFilter: () => Promise<Data>;
    /**
     * Uninstalls a filter with given id. Should always be called when watch is no longer needed. Additonally Filters
     * timeout when they aren't requested with eth_getFilterChanges for a period of time.
     */
    eth_uninstallFilter: (filterId: Data) => Promise<boolean>;
    /**
     * Polling method for a filter, which returns an array of logs which occurred since last poll.
     */
    eth_getFilterChanges: (filterId: Data) => Promise<Array<TxHash> | Array<FilterChange>>;
    /** Returns an array of all logs matching filter with given id. */
    eth_getFilterLogs: (filterId: Data) => Promise<Array<TxHash> | Array<FilterChange>>;
    /** Returns an array of all logs matching a given filter object. */
    eth_getLogs: (options: FilterOptions) => Promise<Array<TxHash> | Array<FilterChange>>;
    /**
     * Returns the hash of the current block, the seedHash, and the boundary condition to be met ("target").
     *
     * @returns Array with the following properties:
     * @alpha
     *
     * DATA, 32 Bytes - current block header pow-hash
     * DATA, 32 Bytes - the seed hash used for the DAG.
     * DATA, 32 Bytes - the boundary condition ("target"), 2^256 / difficulty.
     */
    eth_getWork: (blockHeaderHash: Data) => Promise<Array<TxHash>>;
    /** Used for submitting a proof-of-work solution. */
    eth_submitWork: (data: Data, powHash: TxHash, digest: TxHash) => Promise<boolean>;
    /** Used for submitting mining hashrate. */
    eth_submitHashrate: (hashRate: Data, id: Data) => Promise<boolean>;
    /** Sends a whisper message. */
    shh_post: (data: SHHPost) => Promise<boolean>;
    /** Returns the current whisper protocol version. */
    shh_version: () => Promise<string>;
    /** Creates new whisper identity in the client. */
    shh_newIdentity: () => Promise<Data>;
    /** Checks if the client hold the private keys for a given identity. */
    shh_hasIdentity: (identity: Data) => Promise<boolean>;
    shh_newGroup: () => Promise<Data>;
    shh_addToGroup: (group: Data) => Promise<boolean>;
    /** Creates filter to notify, when client receives whisper message matching the filter options. */
    shh_newFilter: (options: SHHFilterOptions) => Promise<Data>;
    /**
     * Uninstalls a filter with given id. Should always be called when watch is no longer needed.
     * Additonally Filters timeout when they aren't requested with shh_getFilterChanges for a period of time.
     */
    shh_uninstallFilter: (filterId: Data) => Promise<boolean>;
    /**
     * Polling method for whisper filters. Returns new messages since the last call of this method.
     *
     * Note calling the shh_getMessages method, will reset the buffer for this method, so that you won't receive duplicate
     * messages.
     */
    shh_getFilterChanges: (filterId: Data) => Promise<Array<SHHFilterMessage>>;
    /** Get all messages matching a filter. Unlike shh_getFilterChanges this returns all messages. */
    shh_getMessages: (filterId: Data) => Promise<Array<SHHFilterMessage>>;
    /**
     * Decrypts the key with the given address from the key store.
     *
     * Both passphrase and unlock duration are optional when using the JavaScript console. If the passphrase is not
     * supplied as an argument, the console will prompt for the passphrase interactively.
     *
     * The unencrypted key will be held in memory until the unlock duration expires. If the unlock duration defaults to
     * 300 seconds. An explicit duration of zero seconds unlocks the key until geth exits.
     *
     * The account can be used with eth_sign and eth_sendTransaction while it is unlocked.
     */
    personal_unlockAccount: (account: Address, passPhrase?: Data, seconds?: Quantity) => Promise<boolean>;
    /**
     * Generates a new private key and stores it in the key store directory. The key file is encrypted with the given
     * passphrase. Returns the address of the new account.
     *
     * At the geth console, newAccount will prompt for a passphrase when it is not supplied as the argument.
     */
    personal_newAccount: (passPhrase: Data) => Promise<Address>;
    /** Returns all the Ethereum account addresses of all keys in the key store. */
    personal_listAccounts: () => Promise<Array<Address>>;
    /** Removes the private key with given address from memory. The account can no longer be used to send transactions. */
    personal_lockAccount: (address: Address) => Promise<boolean>;
    /**
     * Imports the given unencrypted private key (hex string) into the key store, encrypting it with the passphrase.
     * Returns the address of the new account.
     */
    personal_importRawKey: (keydata: Data, passPhrase: Data) => Promise<Address>;
    /**
     * Imports the given unencrypted private key (hex string) into the key store, encrypting it with the passphrase.
     * Returns the address of the new account.
     */
    personal_sendTransaction: (txObject: TransactionOptions, passPhrase: Data) => Promise<TxHash>;
    /**
     * The sign method calculates an Ethereum specific signature with:
     *   sign(keccack256("Ethereum Signed Message:" + len(message) + message))).
     *
     * By adding a prefix to the message makes the calculated signature recognisable as an Ethereum specific signature.
     * This prevents misuse where a malicious DApp can sign arbitrary data (e.g. transaction) and use the signature to
     * impersonate the victim.
     *
     * See ecRecover to verify the signature.
     */
    personal_sign: (data: Data, signerAddress: Address, passPhrase: Data) => Promise<Data>;
    /**
     * ecRecover returns the address associated with the private key that was used to calculate the signature in
     * personal_sign.
     */
    personal_ecRecover: (message: Data, signature: Data) => Promise<Address>;
    constructor(provider: any);
    /**
     * Should be used to asynchronously send request
     *
     * @param data - The RPC message to be sent
     */
    sendAsync(data: RPCSendableMessage): Promise<any>;
    /**
     * Should be used to set provider of request manager
     *
     * @param p - The provider
     */
    setProvider(p: any): void;
    /**
     * Waits until the transaction finishes. Returns if it was successfull.
     * Throws if the transaction fails or if it lacks any of the supplied events
     * @param txId - Transaction id to watch
     */
    getConfirmedTransaction(txId: string): Promise<FinishedTransactionAndReceipt>;
    /**
     * Wait until a transaction finishes by either being mined or failing
     * @param txId - Transaction id to watch
     * @param retriesOnEmpty - Number of retries when a transaction status returns empty
     */
    waitForCompletion(txId: string, retriesOnEmpty?: number): Promise<FinishedTransactionAndReceipt>;
    /**
     * Returns a transaction in any of the possible states.
     * @param hash - The transaction hash
     */
    getTransaction(hash: string): Promise<Transaction>;
    /**
     * Wait retryAttemps * TRANSACTION_FETCH_DELAY for a transaction status to be in the mempool
     * @param txId - Transaction id to watch
     * @param retryAttemps - Number of retries when a transaction status returns empty
     */
    isTxDropped(txId: string, _retryAttemps?: number): Promise<boolean>;
    /**
     * Get the transaction status and receipt
     * @param txId - Transaction id
     */
    getTransactionAndReceipt(txId: string): Promise<TransactionAndReceipt>;
    /**
     * Expects the result of getTransaction's geth command and returns true if the transaction is still pending.
     * It'll also check for a pending status prop against {@link txUtils#TRANSACTION_STATUS}
     * @param tx - The transaction object
     */
    isPending(tx: TransactionAndReceipt): boolean;
    /**
     * Expects the result of getTransactionRecepeit's geth command and returns true if the transaction failed.
     * It'll also check for a failed status prop against {@link txUtils#TRANSACTION_STATUS}
     * @param tx - The transaction object
     */
    isFailure(tx: TransactionAndReceipt): boolean;
}

declare type RevertedTransaction = TransactionObject & {
    type: TransactionType.reverted;
};

declare type SHHFilterMessage = {
    /** The hash of the message. */
    hash: TxHash;
    /** The sender of the message, if a sender was specified. */
    from: Data;
    /** The receiver of the message, if a receiver was specified. */
    to: Data;
    /** Integer of the time in seconds when this message should expire (?). */
    expiry: Quantity;
    /** Integer of the time the message should float in the system in seconds (?). */
    ttl: Quantity;
    /** Integer of the unix timestamp when the message was sent. */
    sent: Quantity;
    /** Array of DATA topics the message contained. */
    topics: Array<Data>;
    /** The payload of the message. */
    payload: Data;
    /** Integer of the work this message required before it was send (?). */
    workProved: Quantity;
};

declare type SHHFilterOptions = {
    /**
     * (optional) Identity of the receiver. When present it will try to decrypt any incoming message if the client holds the private key to this identity.
     */
    to?: Data;
    /**
     * Array of DATA topics which the incoming message's topics should match. You can use the following combinations:
     * [A, B] = A && B
     * [A, [B, C]] = A && (B || C)
     * [null, A, B] = ANYTHING && A && B null works as a wildcard
     */
    topics: Array<Data>;
};

declare type SHHPost = {
    /** (optional) The identity of the sender. */
    from: Data;
    /** (optional) The identity of the receiver. When present whisper will encrypt the message so that only the receiver can decrypt it. */
    to: Data;
    /** Array of DATA topics, for the receiver to identify messages. */
    topics: Array<Data>;
    /** The payload of the message. */
    payload: Data;
    /** The integer of the priority in a rang from ... (?). */
    priority: Quantity;
    /** integer of the time to live in seconds. */
    ttl: Quantity;
};

declare type Syncing = {
    startingBlock: Quantity;
    currentBlock: Quantity;
    highestBlock: Quantity;
};

declare type Tag = 'latest' | 'earliest' | 'pending';

declare type Transaction = DroppedTransaction | ReplacedTransaction | QueuedTransaction | PendingTransaction | ConfirmedTransaction | RevertedTransaction;

declare type TransactionAndReceipt = TransactionObject & {
    receipt: TransactionReceipt;
};

declare type TransactionCallOptions = {
    /**
     * The address the transaction is sent from.
     */
    from?: Address;
    /**
     * The address the transaction is directed to.
     */
    to: Address;
    /**
     * Integer of the gas provided for the transaction execution. eth_call consumes zero gas, but this parameter
     * may be needed by some executions.
     *
     * Default: 90000
     */
    gas?: Quantity;
    /**
     *  Integer of the gasPrice used for each paid gas
     */
    gasPrice?: Quantity;
    /**
     * Integer of the value sent with this transaction
     */
    value?: Quantity;
    /**
     * The compiled code of a contract OR the hash of the invoked method signature and encoded parameters.
     * For details see Ethereum Contract ABI
     */
    data?: string;
};

declare type TransactionObject = {
    /** hash of the transaction. */
    hash: TxHash;
    /** the number of transactions made by the sender prior to this one. */
    nonce: number;
    /** hash of the block where this transaction was in. null when its pending. */
    blockHash: TxHash;
    /** block number where this transaction was in. null when its pending. */
    blockNumber: number;
    /** integer of the transactions index position in the block. null when its pending. */
    transactionIndex: number;
    /** address of the sender. */
    from: Address;
    /** address of the receiver. null when its a contract creation transaction. */
    to: Address | null;
    /** value transferred in Wei. */
    value: BigNumber;
    /** gas price provided by the sender in Wei. */
    gasPrice: BigNumber;
    /** gas provided by the sender. */
    gas: Quantity;
    /** the data send along with the transaction. */
    input: Data;
    v?: Data;
    r?: Data;
    s?: Data;
};

declare type TransactionOptions = {
    /**
     * The address the transaction is sent from.
     */
    from: Address;
    /**
     * The address the transaction is directed to.
     */
    to: Address;
    /**
     * Integer of the gas provided for the transaction execution. eth_call consumes zero gas, but this parameter
     * may be needed by some executions.
     *
     * Default: 90000
     */
    gas?: Quantity;
    /**
     *  Integer of the gasPrice used for each paid gas
     */
    gasPrice?: Quantity;
    /**
     * Integer of the value sent with this transaction
     */
    value?: Quantity;
    /**
     * The compiled code of a contract OR the hash of the invoked method signature and encoded parameters.
     * For details see Ethereum Contract ABI
     */
    data: string;
    /** Integer of a nonce. This allows to overwrite your own pending transactions that use the same nonce. */
    nonce?: Quantity;
};

declare type TransactionReceipt = {
    /** hash of the transaction. */
    transactionHash: TxHash;
    /** integer of the transactions index position in the block. */
    transactionIndex: Quantity;
    /** hash of the block where this transaction was in. */
    blockHash: TxHash;
    /** block number where this transaction was in. */
    blockNumber: Quantity;
    /** The total amount of gas used when this transaction was executed in the block. */
    cumulativeGasUsed: Quantity;
    /** The amount of gas used by this specific transaction alone. */
    gasUsed: Quantity;
    /**  The contract address created, if the transaction was a contract creation, otherwise null. */
    contractAddress: Address;
    /** Array of log objects, which this transaction generated. */
    logs: Array<FilterLog>;
    /**  256 Bytes - Bloom filter for light clients to quickly retrieve related logs. */
    logsBloom: Data;
    /**  post-transaction stateroot (pre Byzantium) */
    root?: TxHash;
    /** either 1 (success) or 0 (failure) */
    status?: Quantity;
};

declare enum TransactionStatus {
    pending = "pending",
    confirmed = "confirmed",
    failed = "failed"
}

declare enum TransactionType {
    queued = "queued",
    dropped = "dropped",
    replaced = "replaced",
    pending = "pending",
    reverted = "reverted",
    confirmed = "confirmed"
}

/** Hex string of 32 bytes */
declare type TxHash = string;

/**
 * @public
 */
export declare class WebSocketProvider<T extends IWebSocket> {
    url: string;
    options: WebSocketProviderOptions;
    isDisposed: boolean;
    connection: IFuture<T>;
    debug: boolean;
    private lastChunk;
    private lastChunkTimeout;
    constructor(url: string, options?: WebSocketProviderOptions);
    dispose(): void;
    send(): void;
    sendAsync(payload: RPCMessage | RPCMessage[], callback: Callback): void;
    /**
     * Will parse the response and make an array out of it.
     * @method _parseResponse
     * @param {String} data
     */
    private parseResponse;
    private processMessage;
    /**
     * Timeout all requests when the end/error event is fired
     * @method _timeout
     */
    private timeout;
    private connect;
}

declare type WebSocketProviderOptions = {
    /**
     * WebSocketConstructor, used in Node.js where WebSocket is not globally available
     */
    WebSocketConstructor?: any;
    timeout?: number;
    protocol?: string;
};

/**
 * @public
 */
export declare namespace eth {
    const eth_getBalance: Method<import("../utils/BigNumber").BigNumber>;
    const eth_getStorageAt: Method<string>;
    const eth_getCode: Method<string>;
    const eth_getBlockByHash: Method<any>;
    const eth_getBlockByNumber: Method<any>;
    const eth_getUncleByBlockHashAndIndex: Method<any>;
    const eth_getUncleByBlockNumberAndIndex: Method<any>;
    const eth_getBlockTransactionCountByHash: Method<number>;
    const eth_getBlockTransactionCountByNumber: Method<number>;
    const eth_getUncleCountByBlockHash: Method<number>;
    const eth_getUncleCountByBlockNumber: Method<number>;
    const eth_getTransactionByHash: Method<any>;
    const eth_getTransactionByBlockHashAndIndex: Method<any>;
    const eth_getTransactionByBlockNumberAndIndex: Method<any>;
    const eth_getTransactionReceipt: Method<any>;
    const eth_getTransactionCount: Method<number>;
    const eth_sendRawTransaction: Method<string>;
    const web3_sha3: Method<string>;
    const eth_sendTransaction: Method<string>;
    const eth_sign: Method<string>;
    const eth_call: Method<string>;
    const eth_estimateGas: Method<number>;
    const eth_submitWork: Method<boolean>;
    const eth_getWork: Method<any[]>;
    const eth_coinbase: Property<any>;
    const eth_mining: Property<boolean>;
    const eth_hashrate: Property<number>;
    const eth_syncing: Property<any>;
    const eth_gasPrice: Property<import("../utils/BigNumber").BigNumber>;
    const eth_accounts: Property<any[]>;
    const eth_blockNumber: Property<number>;
    const eth_protocolVersion: Property<number>;
    const web3_clientVersion: Property<string>;
    const net_version: Property<string>;
    const shh_version: Method<number>;
    const shh_post: Method<boolean>;
    const personal_newAccount: Method<any>;
    const personal_importRawKey: Method<any>;
    const personal_sign: Method<string>;
    const personal_ecRecover: Method<any>;
    const personal_unlockAccount: Method<boolean>;
    const personal_sendTransaction: Method<string>;
    const personal_lockAccount: Method<boolean>;
    const personal_listAccounts: Property<any[]>;
    const net_listening: Property<boolean>;
    const net_peerCount: Property<number>;
    const eth_newFilter: Method<string>;
    const eth_getLogs: Method<any[]>;
    const eth_newBlockFilter: Method<string>;
    const eth_newPendingTransactionFilter: Method<string>;
    const eth_uninstallFilter: Method<boolean>;
    const eth_getFilterLogs: Method<any[]>;
    const eth_getFilterChanges: Method<any[]>;
    const eth_submitHashrate: Method<boolean>;
    const shh_newIdentity: Method<string>;
    const shh_hasIdentity: Method<boolean>;
    const shh_newGroup: Method<string>;
    const shh_addToGroup: Method<boolean>;
    const shh_newFilter: Method<string>;
    const shh_uninstallFilter: Method<boolean>;
    const shh_getLogs: Method<any[]>;
    const shh_getFilterMessages: Method<any[]>;
    const shh_getFilterChanges: Method<any[]>;
    const shh_getMessages: Method<any[]>;
}

/**
 * @public
 * Should be called to get display name of contract function
 */
export declare function extractDisplayName(name: string): string;

/**
 * @public
 * Should be called to get type name of contract function
 */
export declare function extractTypeName(name: string): string;

/**
 * @public
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 */
export declare function fromAscii(str: string, num?: number): string;

/**
 * @public
 * Converts value to it's hex representation
 */
export declare function fromDecimal(value: string | number | BigNumber): string;

/**
 * @public
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 */
export declare function fromUtf8(_str: string, allowZero?: boolean): string;

/**
 * @public
 * Takes a number of wei and converts it to any other ether unit.
 *
 * Possible units are:
 *   SI Short   SI Full        Effigy       Other
 * - kwei       femtoether     babbage
 * - mwei       picoether      lovelace
 * - gwei       nanoether      shannon      nano
 * - --         microether     szabo        micro
 * - --         milliether     finney       milli
 * - ether      --             --
 * - kether                    --           grand
 * - mether
 * - gether
 * - tether
 *
 */
export declare function fromWei(num: number | string, unit: string): string | BigNumber;

/**
 * @public
 * Returns value of unit in Wei
 */
export declare function getValueOfUnit(_unit: string): BigNumber;

/**
 * @public
 * Checks if the given string is an address
 */
export declare function isAddress(address: any): boolean;

/**
 * @public
 * Returns true if object is array, otherwise false
 */
export declare function isArray(object: any): boolean;

/**
 * @public
 * Returns true if object is BigNumberType, otherwise false
 */
export declare function isBigNumber(object: any): boolean;

/**
 * @public
 * Returns true if given string is a valid Ethereum block header bloom.
 */
export declare function isBloom(bloom: any): boolean;

/**
 * @public
 * Returns true if object is boolean, otherwise false
 */
export declare function isBoolean(object: any): boolean;

/**
 * @public
 * Checks if the given string is a checksummed address
 */
export declare function isChecksumAddress(_address: string): boolean;

/**
 * @public
 * Returns true if object is function, otherwise false
 */
export declare function isFunction(object: any): boolean;

/**
 * @public
 * Converts value to it's decimal representation in string
 */
export declare function isHex(value: string): boolean;

/**
 * @public
 * Returns true if given string is valid json object
 */
export declare function isJson(str: any): boolean;

/**
 * @public
 * Returns true if object is Objet, otherwise false
 */
export declare function isObject(object: any): boolean;

/**
 * @public
 * Checks if the given string is strictly an address
 */
export declare function isStrictAddress(address: any): boolean;

/**
 * @public
 * Returns true if object is string, otherwise false
 */
export declare function isString(value: any): value is string;

/**
 * @public
 * Returns true if given string is a valid log topic.
 */
export declare function isTopic(topic: string): boolean;

/**
 * @public
 * Should be called to pad string to expected length
 */
export declare function padLeft(str: string, chars: number, sign?: string): string;

/**
 * @public
 * Should be called to pad string to expected length
 */
export declare function padRight(str: string, chars: number, sign?: string): string;

/**
 * @public
 */
export declare function sha3(value: string, options?: {
    encoding?: 'hex';
}): any;

/**
 * @public
 * Transforms given string to valid 20 bytes-length addres with 0x prefix
 */
export declare function toAddress(address: any): any;

/**
 * @public
 * Ensures the result will be an array
 */
export declare function toArray(value: any): any[];

/**
 * @public
 * Should be called to get ascii from it's hex representation
 */
export declare function toAscii(hex: string): string;

/**
 * @public
 * Takes an input and transforms it into an bignumber
 */
export declare function toBigNumber(_num: number | string | BigNumber): BigNumber;

/**
 * @public
 * Converts value to it's boolean representation (x != 0)
 */
export declare function toBoolean(value: number | string | BigNumber | boolean): boolean;

/**
 * @public
 * Makes a checksum address
 */
export declare function toChecksumAddress(_address: string): string;

/**
 * @public
 * Converts value to it's hex  representation in string
 */
export declare function toData(val: string | number | BigNumber): string;

/**
 * @public
 * Converts value to it's decimal representation in string
 */
export declare function toDecimal(value: number | string | BigNumber): number;

/**
 * @public
 * Auto converts any given value into it's hex representation.
 *
 * And even stringifys objects before.
 */
export declare function toHex(val: string | number | BigNumber): string;

/**
 * @public
 * Converts value to it's decimal representation in string
 */
export declare function toNullDecimal(value: number | string | BigNumber): string | number | BigNumber;

/**
 * @public
 * Converts value to string
 */
export declare function toString(value: number | string | BigNumber): string;

/**
 * @public
 * Takes and input transforms it into bignumber and if it is negative value, into two's complement
 */
export declare function toTwosComplement(num: number | string | BigNumber): BigNumber;

/**
 * @public
 * Should be called to get utf8 from it's hex representation
 */
export declare function toUtf8(hex: string): any;

/**
 * @public
 * Takes a number of a unit and converts it to wei.
 *
 * Possible units are:
 *   SI Short   SI Full        Effigy       Other
 * - kwei       femtoether     babbage
 * - mwei       picoether      lovelace
 * - gwei       nanoether      shannon      nano
 * - --         microether     szabo        micro
 * - --         milliether     finney       milli
 * - ether      --             --
 * - kether                    --           grand
 * - mether
 * - gether
 * - tether
 */
export declare function toWei(num: number | string, unit: string): string | BigNumber;

/**
 * @public
 * Should be used to create full function/event name from json abi
 */
export declare function transformToFullName(json: {
    name: string;
    inputs: any[];
}): string;
